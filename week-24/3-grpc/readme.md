# What is RPC

RPC stands for `remote procedure call` . As the name suggests, it lets you call a function in on a different process/server/backend and get back a response from it.

## Why remote procedure call?

This is how we’ve made our backends talk to each other until now.
We send out an `http request` , get back a response.

There are a few flaws in this approach

1. No types. You don’t know what is the shape of the data you will get back. You might be able to share types between 2 Node.js backends somehow, but if the other backend is in Rust, then you cant get back the types from it
2. We use JSON to serialize and deserialize data
3. We have to know what axios is , or what fetch is . We need to understand HTTP and how to call it
4. Not language agnostic at all. We have to use a different library in Java, go, rust to send an http request to the server

## Benefits

Better types - The `getTodos` function has an associated type of the data being returned.
We are still using json, but we will fix that soon (json is slow)
We dont need to use axios anymore, all we have to do is call a function
If we can get `autogenerated` code for all languages (go, rust), then this becomes language agnostice

install `axios`
set the `tsconfig.json` with `moduleResolution` set to `node`
compile it down

# Proto buffs

Protocol buffers are Google’s language-neutral, platform-neutral, extensible mechanism for serializing structured data – think XML, JSON.
The protocol buffers are where we define our service definitions and messages. This will be like a contract or common interface between the client and server on what to expect from each other; the methods, types, and returns of what each operation would bear.

Schema Definition Language
Binary Serialization
Language Support and Code Generation

## Serializing and deserializing data (hard)

create a simple proto file-> index2.js, a.proto

```bash
npm init -y
npm i protobufjs
```
